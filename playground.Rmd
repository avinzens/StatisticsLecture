---
title: "Playground"
output: html_notebook
---

```{r, echo=FALSE}
source("config.R")
if (!require("pacman")) install.packages("pacman", repos='https://stat.ethz.ch/CRAN/'); library(pacman)
p_load(ggplot2, grid, DT, dplyr, tidyr, knitr, httpuv, shiny, modeest, scatterD3, ggvis)
```

#Purpose
This series of statistics and experimental design lectures is designed for an introductory class in HCI.
It aims to help students scaffold a mental model of how statistics works and why it makes sense.
At the end of this lecture series, students should be able to read and make educated judgement about statistics that are used in HCI literature.


#Concepts from the previous lecture
Three types of knowledge:

* **Descriptive:** accurate description of what is happening
* **Relational:** relationship between multiple variables
* **Causative:** causes of a situation or a set of event

Sampling:

* **Population:** All individuals of interest
* **Sampling:** Specific individuals who participate in the study

Variables involved in an experiment:

* **Independent variables:** The variables that are manipulated in order to observe their effects.
* **Dependent variables:** The variables that are measured and compared. Changing independent variables are expected to influence the changes of the dependent variables.
* **Extraneous variables:** The variables that are prevented from intervening in the cause-effect relationship between the independent variables and the dependent variables.


#Scales
Each variable that we manipulate or measure is in one of the following *scales of measurement:*

* **Nominal scales:** These are a qualitative categories. (Some calls this scale a **categorical scale**) For example, gender $\in$ {male, female}, input device $\in$ {Mouse, Keyboard} study subject $\in$ {Math, Science, Language, Arts}. There is no natural order.
* **Ordinal scales:** An ordinal scales has a natural *order* Therefore, it is possible to rank values in this scale. For example, shirt size $\in$ {small, medium, large} or an answer from a Likert item $\in$ {strongly disagree, disagree, neutral, agree, strongly agree}. It is possible to order the levels in this scale. The difference between each level does not have any arithmatical meaning. In a Likert item, for example, one cannot say that the difference between "disagree" and "neutral" does not necessarily equal to the difference between "neutral" and "agree".
* **Interval scales:** Values in an interval scale is organized as a sequence of equal intervals. For example, temperature in degrees Celsius: the difference between 1 and 2 degrees Celsius equals to the difference between 2 and 3 degrees Celsius. However, for this scale, the value zero is assigned at arbitrary point. For example, at 0 degrees Celsius does not mean that there is no temperature. Variables in the interval scale that have arbitrary zero point is pretty rare.
* **Ratio scales:** A ratio scale is an interval scale that has a meaningful zero point. The zero point represents a total absence of the property described by the scale, for example, task completion time in seconds (TCT), error rate in percents, temperature in Kelvin. In ratio scales, it is possible to describe a difference in ratio, e.g., an individual who took 10 seconds to complete a task (10 more than 0) is twice slower than another who requires 5 seconds (5 more than 0).

 The interval and the ratio scales differs only at the definition of the zero point. Thus, it's possible that one unit of measurement can be treated differently. For example, measuring the task completion time in second results in a ratio scale. Measuring the *difference of the task completion time from the average* is only result in an interval scale. This is because "10 seconds faster than the average" is not twice slower as "5 seconds faster than the average".

##Showing data in different scales

Suppose we have the following data:

```{r, echo=FALSE}
n <- 30
satLevels <- c("Strongly dissatisfied", "Dissatisfied", "Neutral", "Satrisfied", "Strongly satisfied")
df <- data.frame(
  UserId=1:n, 
  Major=sample(c("Math", "Science", "Language", "Arts"), n, replace=T),
  Satisfaction=factor(sample(satLevels, n, replace=T), levels = satLevels),
  TaskCompletionTime=rnorm(n, mean = 15, sd = 2)
)
displayTable(df, height = 200)
```
### Nominal data: study majors of participants
We can show the nominal data as a stack of dots. Each dot represent a participant.
```{r, echo=FALSE}
pMajor <- ggplot(df, aes(x=Major)) + 
  geom_dotplot(binwidth = 1/10) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
pMajor
```
Note that for data in the nominal scale, the order of the category doesn't matter. This the graph above is the same as the following graph:

```{r, echo=FALSE}
df$Major <- relevel(df$Major, "Math")
df$Major <- relevel(df$Major, "Science")
ggplot(df, aes(x=Major)) + 
  geom_dotplot(binwidth = 1/10) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```


### Ordinal data: satisfaction rate
Here, it does matter to show the data in order from "Strongly dissatisfied" to "Strongly satisfied".
```{r, echo=FALSE}
pSatisfaction <- ggplot(df, aes(x=Satisfaction)) + 
  geom_dotplot(binwidth = 1/10) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
pSatisfaction
```

### Ratio data: task completion time
For ratio data, like task completion time, there are a lot of distinct numbers, some differs only at decimal places. Therefore, it's not useful to use stacked dot plot. Instead, we use the **histogram**. A histogram has defines *bins* which is usually equal intervals. Data points are groupped by the bins. The number of data points in each bin is represented by the height of each bar. Below, the histogram (grey) is superimposed with the raw data dots (unstacked, in blue).


```{r, echo=FALSE}
pTct  <- ggplot(df, aes(x=TaskCompletionTime)) +
  geom_histogram(binwidth=1, colour = "black") +
  geom_point(aes(y=0, x = TaskCompletionTime), alpha = 0.5, color="blue") + 
  scale_x_continuous(
    limits = c(0, max(df$TaskCompletionTime) + 2),
    breaks = 0:(max(df$TaskCompletionTime) + 2)
    ) +
  theme(panel.grid.minor = element_blank())

suppressWarnings(print(pTct))  # suppress spurious warning from geom_bar
```

Changing the bin width may change how the histogram looks. try this out in the Viewer pane by uncommenting the last line (removing the "#" at the beginning of the line) and run it.

```{r, include=FALSE}
# TODO: deprecated, use ggvis version below instead
binner <- shinyApp(
    ui = fluidPage(
      sidebarLayout(
        sidebarPanel(
          sliderInput("binwidth", label = "bin width:",
              min = 1, max = 5, value = 1, step = 0.1)
          ),
        mainPanel(
          plotOutput(
            "hist", 
            brush = brushOpts(id = "plot_brush", direction = c("x"))
          )
        )
      )
    ), 
    server = function(input, output) {
      output$hist <- renderPlot({
        ggplot(df, aes(x = TaskCompletionTime)) +
          geom_histogram(binwidth = input$binwidth, colour = "black") +
          geom_point(aes(y = 0, x = TaskCompletionTime), alpha = 0.5, color = "blue") + 
          scale_x_continuous(
            limits = c(0, max(df$TaskCompletionTime) + 10),
            breaks = 0:(max(df$TaskCompletionTime) + 10)
            ) +
          ylim(0, nrow(df)) +
          theme(panel.grid.minor = element_blank())
      })
    }
  )
# runApp(binner, launch.browser = rstudioapi::viewer)

```

ggvis version:
```{r}
pHistBase <- df %>% 
  ggvis(~TaskCompletionTime) %>% 
  layer_points(y := 0, fillOpacity := 0.5, fill := "blue") %>%
  scale_numeric("x", domain = c(0, max(df$TaskCompletionTime) + 2), nice = FALSE)

pHistogram <- pHistBase %>% 
  layer_histograms(width = 1)

iHistogram <- pHistBase %>% 
  layer_histograms(width = input_slider(min = 1, max = 5, value = 1, step = 0.5))

pHistogram # non-interactive version
# iHistogram # remove the "#" at the beginning of the line to run
             # (Hint: use Cmd + / (mac) or Ctrl + / (Windows, Linux) to toggle)
```

#Describing data
There are several things that we can say about data. We will be *describing* the dataset itself. We usually interest in whereabout the data points tend to be. There are several statistics that are useful for this. 

##Mode
The *mode* of a data is the score or category with the greatest frequency. This usually makes sense in nominal and ordinal data.

```{r, echo = FALSE}
Mode <- function(x) {
  ux <- unique(x)
  tab <- tabulate(match(x, ux)); ux[tab == max(tab)]
}
majorModes <- as.character(Mode(df$Major))
satModes <- as.character(Mode(df$Satisfaction))
pMajor + annotate("text", x = 2, y = 8, label = sprintf("Mode(s): %s", paste(majorModes, collapse = ", "))) 
pSatisfaction + annotate("text", x = 2, y = 8, label = sprintf("Mode(s): %s", paste(satModes, collapse = ", "))) 
```

For interval data, since it may be rare that the data are exactly at the same place. model calculation usually based on estimating the probability density of the data.
```{r, echo = FALSE}
tct.mode <- modeest::mlv(df$TaskCompletionTime, method = "naive")
# plot(tct.mode)
pTct
ggplot(df, aes(x=TaskCompletionTime)) +
  geom_density() +
  geom_point(aes(y=0, x = TaskCompletionTime), alpha = 0.5, color="blue") + 
  geom_vline(xintercept=tct.mode$M, color = "red") + 
  annotation_custom(
    textGrob(sprintf("Mode(s): %s", paste(format(tct.mode$M, digits = 4), collapse = ", "))), 
    xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) +
  scale_x_continuous(
    limits = c(0, max(df$TaskCompletionTime) + 2),
    breaks = 0:(max(df$TaskCompletionTime) + 2)
    ) +
  theme(panel.grid.minor = element_blank())

```


#Inferring from the data
Here, we are inferring about the population (contrast to *describing* as above).



#Temp

[Plot interactions](https://shiny.rstudio.com/gallery/plot-interaction-advanced.html)
[ggvis](http://ggvis.rstudio.com/cookbook.html)



[scatterd3](https://cran.r-project.org/web/packages/scatterD3/vignettes/introduction.html)
```{r}
scatterD3(data = mtcars, x = wt, y = mpg, fixed = TRUE, 
          lines = data.frame(slope = 1, intercept = 0))
```
