---
title: "Playground"
output: html_document
runtime: shiny
---

```{r, echo=FALSE}
source("config.R")
if (!require("pacman")) install.packages("pacman", repos='https://stat.ethz.ch/CRAN/'); library(pacman)
p_load(ggplot2, 
       grid, 
       DT, 
       dplyr, 
       tidyr, 
       knitr, 
       httpuv, 
       shiny, 
       scatterD3, 
       ggvis,
       cowplot)

theme_set(theme_gray()) # disable cowplot white theme
```

<!---
```{r child = 'chapter1.Rmd'}
```
--->

```{r, echo=FALSE}
n <- 30
satLevels <- c("Strongly dissatisfied", "Dissatisfied", "Neutral", "Satrisfied", "Strongly satisfied")
df <- data.frame(
  UserId=1:n, 
  Major=sample(c("Math", "Science", "Language", "Arts"), n, replace=T),
  Satisfaction=factor(sample(satLevels, n, replace=T), levels = satLevels),
  TaskCompletionTime=rnorm(n, mean = 15, sd = 2)
)
displayTable(df)
```

### Nominal data: study majors of participants

We can show the nominal data as a stack of dots. Each dot represent a participant.

Note that for data in the nominal scale, the order of the category doesn't matter. The following two graphs shows the same data.

```{r, echo=FALSE, fig.height = 3}

pMajor <- ggplot(df, aes(x=Major)) + 
  geom_dotplot(binwidth = 1/10) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

df2 <- df
df2$Major <- relevel(df2$Major, "Math")
df2$Major <- relevel(df2$Major, "Science")

pMajor2 <- pMajor %+% df2

plot_grid(pMajor, pMajor2, align='h')
```





### Ordinal data: satisfaction rate
Here, it does matter to show the data in order from "Strongly dissatisfied" to "Strongly satisfied".
```{r, echo=FALSE, fig.height = 3}
pSatisfaction <- ggplot(df, aes(x=Satisfaction)) + 
  geom_dotplot(binwidth = 1/10) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
pSatisfaction
```

### Ratio data: task completion time
For ratio data, like task completion time, there are a lot of distinct numbers, some differs only at decimal places. Therefore, it's not useful to use stacked dot plot. Instead, we use the **histogram**. A histogram has defines *bins* which is usually equal intervals. Data points are groupped by the bins. The number of data points in each bin is represented by the height of each bar. Below, the histogram (grey) is superimposed with the raw data dots (unstacked, in blue).

Changing the bin width may change how the histogram looks. Try this out with the slider below the histogram

```{r, echo=FALSE}
iTCTBase <- df %>% 
  ggvis(~TaskCompletionTime) %>% 
  scale_numeric("x", domain = c(0, max(df$TaskCompletionTime) + 2), nice = FALSE) 

# pTCTWidget <- function() {
#   shinyApp(
#     ui = fluidPage(
#           uiOutput("p_ui"),
#           ggvisOutput("pTCT")
#          ), #fluid page  # ui
#     
#     server = function(input, output, session) {
#       pTCT %>%
#         bind_shiny("pTCT", "p_ui") 
#     }, # server
#     options = list(height = 200)
#   ) #shinyAPP
# }
# pTCTWidget()
```


```{r, echo = FALSE, fig.height = 3, fig.width = 5}
binWidthSlider <- input_slider(min = 1, max = 5, value = 1, step = 0.5)
iTCTBase %>%
  layer_histograms(width = binWidthSlider, fill := "gray") %>%
  layer_points(y = 0, fillOpacity := 0.5, fill := "blue")
```

#Describing data
There are several things that we can say about data. We will be *describing* the dataset itself. We usually interest in whereabout the data points tend to be. There are several statistics that are useful for this. 

##Mode
The *mode* of a data is the score or category with the greatest frequency. This usually makes sense in nominal and ordinal data.

```{r, echo = FALSE, fig.height = 3}
Mode <- function(x) {
  ux <- unique(x)
  tab <- tabulate(match(x, ux)); ux[tab == max(tab)]
}
majorModes <- as.character(Mode(df$Major))
satModes <- as.character(Mode(df$Satisfaction))

txtModeMaj <- sprintf("Mode(s): %s", paste(majorModes, collapse = ", "))
txtModeSat <- sprintf("Mode(s): %s", paste(satModes, collapse = ", "))

pModeMajor <- pMajor + annotate("text", x = 2.5, y = 8, label = txtModeMaj)
pModeSat <- pSatisfaction + annotation_custom(
    textGrob(txtModeSat), 
    xmin = -Inf, xmax = Inf, ymin = 1, ymax = 1)

plot_grid(
  pModeMajor,
  pModeSat,
  ncol = 2
)
```

For interval data, since it may be rare that the data are exactly at the same place. model calculation usually based on estimating the probability density of the data.


```{r, echo = FALSE}
tct.mode <- modeest::mlv(df$TaskCompletionTime, method = "naive")
# plot(tct.mode)

pTCT  <- ggplot(df, aes(x=TaskCompletionTime)) +
  geom_histogram(binwidth=1, colour = "black") +
  geom_point(aes(y=0, x = TaskCompletionTime), alpha = 0.5, color="blue") + 
  scale_x_continuous(
    limits = c(0, max(df$TaskCompletionTime) + 2),
    breaks = 0:(max(df$TaskCompletionTime) + 2)
    ) +
  theme(panel.grid.minor = element_blank())



# TODO: once ggvis supports drawing horizontal line, change the plot below to ggvis
pMode <- ggplot(df, aes(x=TaskCompletionTime)) +
  geom_density() +
  geom_point(aes(y=0, x = TaskCompletionTime), alpha = 0.5, color="blue") + 
  geom_vline(xintercept=tct.mode$M, color = "red") + 
  annotation_custom(
    textGrob(sprintf("Mode(s): %s", paste(format(tct.mode$M, digits = 4), collapse = ", "))), 
    xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) +
  scale_x_continuous(
    limits = c(0, max(df$TaskCompletionTime) + 2),
    breaks = 0:(max(df$TaskCompletionTime) + 2)
    ) +
  theme(panel.grid.minor = element_blank())

suppressWarnings(plot_grid(pTCT, pMode, nrow = 2)) # suppress spurious warning from geom_bar

```

##Median
```{r, echo = FALSE}
shinyAppDir(
  "apps/01_descriptives",
  options=list(
    width="500px", height="700px"
  )
)
```


##Mean

Try out the relationship between mean, median, and mode in [Plop It!](http://www.shodor.org/interactivate/activities/PlopIt/)



#Inferring from the data
Here, we are inferring about the population (contrast to *describing* as above).



#Temp

[Plot interactions](https://shiny.rstudio.com/gallery/plot-interaction-advanced.html)
[ggvis](http://ggvis.rstudio.com/cookbook.html)



[scatterd3](https://cran.r-project.org/web/packages/scatterD3/vignettes/introduction.html)
```{r}
scatterD3(data = mtcars, x = wt, y = mpg, fixed = TRUE, 
          lines = data.frame(slope = 1, intercept = 0))
```
