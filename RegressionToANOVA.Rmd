---
title: "Statistics for HCI"
author: "Chat Wacharamanotham"
date: "October 19, 2017"
runtime: shiny
---

<style type="text/css">

body{ /* Normal  */
   font-size: 24px;
}
td {  /* Table  */
   font-size: 24px;
}
h1 { /* Header 1 */
 font-size: 28px;
 color: DarkBlue;
}
h2 { /* Header 2 */
 font-size: 22px;
 color: DarkBlue;
}
h3 { /* Header 3 */
 font-size: 18px;
 color: DarkBlue;
}
code.r{ /* Code block */
  font-size: 24px;
}
pre { /* Code block */
  font-size: 24px
}
</style>



```{r setup, echo=FALSE, include = FALSE}
if (!require("pacman")) install.packages("pacman", repos='https://stat.ethz.ch/CRAN/'); library(pacman)
p_load(ggplot2, DT, dplyr, tidyr)

```

```{r, echo=FALSE}
shinyPlotWidth <- 800
shinyPlotHeight <- 600
```




----

#Interactive 1

Recall the linear equation below?
$$y = \beta_0 + \beta_1x$$
$\beta_0$ is the intercept to the y-axis and $\beta_1$ is the slope. Suppose that we have a linear equation with the parameters below, we can plot this equation on the following graph.

```{r, echo=FALSE}
inputPanel(
  sliderInput("beta0", label = "\\(\\beta_0\\):",
              min = -20, max = 30, value = 5),

  sliderInput("beta1", label = "\\(\\beta_1\\):",
              min = -7, max = 7, value = 5)
  
)

renderPlot({
  b0 <- as.numeric(input$beta0)
  b1 <- as.numeric(input$beta1)
  twoPoints <- data.frame(x = c(0, 1), y = c(b0, (b0 + b1 * 1)))

  baseThemeSetup()
  ggplot(twoPoints, aes(x = x, y = y)) +
    geom_blank() +
    geom_abline(intercept = b0, slope = b1, size = input$lineSize) +
    geom_point(data = twoPoints, size = input$pointSize) +
    geom_text(data = twoPoints, aes(label= paste0("(", x, ",", y, ")")),
               angle = 60, hjust = 0, vjust = 0, size = input$textSize)+
    coord_cartesian(xlim= c(0,10), ylim = c(0, 40))
}, width = shinyPlotWidth, height = shinyPlotHeight)

renderUI({
  b0 <- as.numeric(input$beta0)
  b1 <- as.numeric(input$beta1)
  list(
  withMathJax(sprintf("\\( \\beta_0 \\) is the y-intercept: when \\( x \\) is zero, \\( y \\) is %d", b0)),
  br(),
  withMathJax(sprintf("\\( \\beta_0 \\) is the slope: as \\( x \\) increases one unit, \\( y \\) increases %d units", b1))
  )
})

```
These two basic concepts will be useful later on.


#Interactive 2
Suppose we have a dataset of $x$ and $y$, we can plot them out. We can see how the data differ from our line by calculate **the sum of square error**. We call this Residual sum of square $SS\_R$.
```{r, echo=FALSE}
data1 <- data.frame(x = c(4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 20, 22, 23, 24, 24, 24, 24, 25),
                   y = c(2, 10, 4, 22, 16, 10, 18, 26, 34, 17, 28, 14, 20, 24, 28, 26, 34, 34, 46, 26, 36, 60, 80, 20, 26, 54, 32, 40, 32, 40, 50, 42, 56, 76, 84, 36, 46, 68, 32, 48, 52, 56, 64, 66, 54, 70, 92, 93, 120, 85))
#datatable(data1)
```

```{r, echo=FALSE}
calcError <- function(data, b0, b1) {
  data.frame(x = data$x, y = data$y, xend = data$x, yend = b0 + b1 * data$x)
}

inputPanel(
  sliderInput("b0", label = "\\(\\beta_0\\):",
              min = -20, max = 30, value = -10),

  sliderInput("b1", label = "\\(\\beta_1\\):",
              min = -7, max = 7, value = 5),

  # show sum of square error
  renderUI({
      errLines <- calcError(data1, input$b0, input$b1)
      SS_R <- sum((errLines$yend - errLines$y)^2)
      withMathJax(sprintf("Sum of squared residuals: \\(SSR\\) = %d", SS_R))
  })
)

renderPlot({

  meanY <- mean(data1$y)
  errLines <- calcError(data1, input$b0, input$b1)

  baseThemeSetup()
  ggplot(data1, aes(x = x, y = y)) +
    #geom_hline(yintercept=meanY, color = "darkgray", size = input$grayedLineSize) +
    geom_abline(intercept = input$b0, slope = input$b1, size = input$lineSize) +
    geom_segment(data = errLines, aes(x = x, y = y, xend = xend, yend = yend),
                 linetype = "dotted", color = "red", size = input$dashedLineSize) +
    geom_point(size = input$pointSize) +
    coord_cartesian(xlim= c(0,30), ylim = c(0,125))
}, width = shinyPlotWidth, height = shinyPlotHeight)
```



#Interactive 3
```{r, echo=FALSE}
N <- nrow(data1)
```

**Mean square error:** average error per data point $MS_R = \frac{SS_R}{df_R}$ ($df_R$: degrees of freedom. Here: $N - 1$: `r N - 1`.)

**F-ratio:** ratio between the total mean square error $MS_T$ and the residual mean square error $MS_R$
$F = \frac{MS_T}{MS_R}$
```{r, echo=FALSE}
inputPanel(
  list(
    HTML("Black line:"),
    sliderInput("blk_b0", label = "\\(\\beta_0\\):",
              min = -20, max = 30, value = -17),
    sliderInput("blk_b1", label = "\\(\\beta_1\\):",
              min = -7, max = 7, value = 4),
    
    # show sum of square error
    renderUI({
      errLines <- calcError(data1, input$blk_b0, input$blk_b1)
      SS_R <- sum((errLines$yend - errLines$y)^2)
      withMathJax(sprintf("\\(SS_R\\) = %.2f\n \\( MS_R\\) = %.2f", SS_R, SS_R / (N - 1)))
    })
    
  ),
  list(
    HTML("Gray line:"),
    sliderInput("g_b0", label = "\\(\\beta_0\\):",
              min = 0, max = 80, value = 40),
    HTML("\\(\\beta_1\\): 0"),
    
    # show sum of square error
    renderUI({
      errLines <- calcError(data1, input$g_b0, 0)
      SS_T <- sum((errLines$yend - errLines$y)^2)
      withMathJax(sprintf("\\(SS_T\\) = %.2f\n", SS_T))
    })
  ),
  list(
    renderUI({
      errLines <- calcError(data1, input$blk_b0, input$blk_b1)
      SS_R <- sum((errLines$yend - errLines$y)^2)
      
      g_errLines <- calcError(data1, input$g_b0, 0)
      SS_T <- sum((g_errLines$yend - g_errLines$y)^2)
      
      SS_M <- SS_T - SS_R
      
      withMathJax(sprintf("\\(SS_M\\) = %.2f\n", SS_M))
    })
  )
)

# F-ratio
# renderUI({
#   errLines <- calcError(data1, input$blk_b0, input$blk_b1)
#   SS_R <- sum((errLines$yend - errLines$y)^2)
#   MS_R <- SS_R / N
#   
#   g_errLines <- calcError(data1, input$g_b0, 0)
#   SS_T <- sum((g_errLines$yend - g_errLines$y)^2)
#   MS_T <- SS_T / N
#   
#   FValue <- MS_T / MS_R
#   
#   withMathJax(sprintf("\\(F = \\frac{MS_T}{MS_R} = \\frac{%.2f}{%.2f} = %.2f \\)",
#                       MS_T, MS_R, FValue))
# })

plotModel <- renderPlot({
  errLines <- calcError(data1, input$blk_b0, input$blk_b1)
  
  baseThemeSetup()
  ggplot(data1, aes(x = x, y = y)) +
    geom_abline(intercept = input$blk_b0, slope = input$blk_b1, size = input$lineSize) +
    geom_segment(data = errLines, aes(x = x, y = y, xend = xend, yend = yend),
                 linetype = "dotted", color = "red", size = input$dashedLineSize) +
    geom_point(size = input$pointSize) +
    coord_cartesian(xlim= c(0,30), ylim = c(0,125))
  
}, width = shinyPlotWidth * 0.75, height = shinyPlotHeight* 0.75)

plotNull <- renderPlot({
      errLines_g <- calcError(data1, input$g_b0, 0)
      
      baseThemeSetup()
      ggplot(data1, aes(x = x, y = y)) +
          geom_hline(yintercept=input$g_b0, color = "darkgray", size = input$grayedLineSize) +
          geom_segment(data = errLines_g, aes(x = x, y = y, xend = xend, yend = yend),
                       linetype = "dotted", color = "red", size = input$dashedLineSize) +
          geom_point(size = input$pointSize) +
          coord_cartesian(xlim= c(0,30), ylim = c(0,125))
      
    }, width = shinyPlotWidth* 0.75, height = shinyPlotHeight* 0.75)


fluidRow(splitLayout(cellWidths = c("50%", "50%"), plotModel, plotNull))
```



Actually, there is an algorithm to find the best line. This is call ordinary least square.

```{r}
m <- lm(y ~ x, data1)
```

```{r, echo=FALSE}
b0 <- m$coefficients[1]
b1 <- m$coefficients["x"]
```

Which gives us $\beta_0$ = `r sprintf("%.2f", b0)` and $\beta_1$ = `r sprintf("%.2f", b1)`. Let's plot this:
```{r, echo=FALSE}
renderPlot({
  errLines <- calcError(data1, b0, b1)
      
  baseThemeSetup()
  ggplot(data1, aes(x = x, y = y)) +
    geom_segment(data = errLines, aes(x = x, y = y, xend = xend, yend = yend),
                       linetype = "dotted", color = "red", size = input$dashedLineSize) +
    geom_point(size = input$pointSize) +
    geom_abline(intercept = b0, slope = b1 , size = input$lineSize) +
    coord_cartesian(xlim= c(0,30), ylim = c(0,125))
}, width = shinyPlotWidth* 0.75, height = shinyPlotHeight* 0.75)
```


```{r}
summary(m)
m0 <- lm(y ~ 1, data1)
anova(m0, m)
anova(m)
```


-----

# Display controls
Look & feel parameters

* shinyPlotWidth: `r shinyPlotWidth` px
* shinyPlotHeight: `r shinyPlotHeight` px
```{r, echo=FALSE}
inputPanel(
  sliderInput("baseSize", label = "baseSize:",
              min = 10, max = 40, value = 31),
  
  sliderInput("pointSize", label = "pointSize:",
              min = 1, max = 10, value = 3),
  
  sliderInput("lineSize", label = "lineSize:",
              min = 1, max = 10, value = 2),
  
  sliderInput("grayedLineSize", label = "grayedLineSize:",
              min = 1, max = 10, value = 3),
 
  sliderInput("dashedLineSize", label = "dashedLineSize:",
              min = 1, max = 10, value = 2),
  sliderInput("textSize", label = "textSize:",
              min = 7, max = 20, value = 11)
)

baseThemeSetup <- function() {
  theme_set(theme_dark(base_size = input$baseSize)) 
}

```
